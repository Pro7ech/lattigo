package rlwe

import (
	"bufio"
	"fmt"
	"io"

	"github.com/Pro7ech/lattigo/ring"
	"github.com/Pro7ech/lattigo/utils/buffer"
	"github.com/Pro7ech/lattigo/utils/structs"
	"github.com/google/go-cmp/cmp"
)

// SecretKey is a type for generic RLWE secret keys.
// The Value field stores the polynomial in NTT and Montgomery form.
type SecretKey struct {
	MetaData
	ring.Point
}

// NewSecretKey generates a new SecretKey with zero values.
func NewSecretKey(params ParameterProvider) (sk *SecretKey) {
	sk = new(SecretKey)
	sk.FromBuffer(params, make([]uint64, sk.BufferSize(params)))
	sk.MetaData = MetaData{IsNTT: true, IsMontgomery: true}
	return
}

// BufferSize returns the minimum buffer size
// to instantiate the receiver through [FromBuffer].
func (sk *SecretKey) BufferSize(params ParameterProvider) int {
	p := *params.GetRLWEParameters()
	return new(ring.Point).BufferSize(p.N(), p.MaxLevelQ(), p.MaxLevelP())
}

// FromBuffer assigns new backing array to the receiver.
// Method panics if len(buf) is too small.
// Minimum backing array size can be obtained with [BufferSize].
func (sk *SecretKey) FromBuffer(params ParameterProvider, buf []uint64) {
	if size := sk.BufferSize(params); len(buf) < size {
		panic(fmt.Errorf("invalid buffer size: len(buf)=%d < %d", len(buf), size))
	}

	p := *params.GetRLWEParameters()
	sk.Point.FromBuffer(p.N(), p.MaxLevelQ(), p.MaxLevelP(), buf)
}

// Equal performs a deep equal.
func (sk SecretKey) Equal(other *SecretKey) bool {
	return sk.Point.Equal(&other.Point)
}

// Clone creates a deep copy of the receiver secret key and returns it.
func (sk SecretKey) Clone() *SecretKey {
	return &SecretKey{Point: *sk.Point.Clone(), MetaData: sk.MetaData}
}

func (sk *SecretKey) isEncryptionKey() {}

// AsPlaintext wraps the receiver into an [rlwe.Plaintext].
func (sk *SecretKey) AsPlaintext() *Plaintext {
	return &Plaintext{
		Point:    &sk.Point,
		MetaData: &sk.MetaData,
	}
}

// BinarySize returns the serialized size of the object in bytes.
func (sk SecretKey) BinarySize() (size int) {
	return sk.MetaData.BinarySize() + sk.Point.BinarySize()
}

// WriteTo writes the object on an io.Writer. It implements the io.WriterTo
// interface, and will write exactly object.BinarySize() bytes on w.
//
// Unless w implements the buffer.Writer interface (see lattigo/utils/buffer/writer.go),
// it will be wrapped into a bufio.Writer. Since this requires allocations, it
// is preferable to pass a buffer.Writer directly:
//
//   - When writing multiple times to a io.Writer, it is preferable to first wrap the
//     io.Writer in a pre-allocated bufio.Writer.
//   - When writing to a pre-allocated var b []byte, it is preferable to pass
//     buffer.NewBuffer(b) as w (see lattigo/utils/buffer/buffer.go).
func (sk SecretKey) WriteTo(w io.Writer) (n int64, err error) {
	switch w := w.(type) {
	case buffer.Writer:

		var inc int64

		if inc, err = sk.MetaData.WriteTo(w); err != nil {
			return n + inc, err
		}

		n += inc

		if inc, err = sk.Point.WriteTo(w); err != nil {
			return n + inc, err
		}

		return n + inc, err
	default:
		return sk.WriteTo(bufio.NewWriter(w))
	}
}

// ReadFrom reads on the object from an io.Writer. It implements the
// io.ReaderFrom interface.
//
// Unless r implements the buffer.Reader interface (see see lattigo/utils/buffer/reader.go),
// it will be wrapped into a bufio.Reader. Since this requires allocation, it
// is preferable to pass a buffer.Reader directly:
//
//   - When reading multiple values from a io.Reader, it is preferable to first
//     first wrap io.Reader in a pre-allocated bufio.Reader.
//   - When reading from a var b []byte, it is preferable to pass a buffer.NewBuffer(b)
//     as w (see lattigo/utils/buffer/buffer.go).
func (sk *SecretKey) ReadFrom(r io.Reader) (n int64, err error) {
	switch r := r.(type) {
	case buffer.Reader:

		var inc int64

		if inc, err = sk.MetaData.ReadFrom(r); err != nil {
			return n + inc, err
		}

		n += inc

		if inc, err = sk.Point.ReadFrom(r); err != nil {
			return n + inc, err
		}

		return n + inc, err

	default:
		return sk.ReadFrom(bufio.NewReader(r))
	}
}

// MarshalBinary encodes the object into a binary form on a newly allocated slice of bytes.
func (sk SecretKey) MarshalBinary() (data []byte, err error) {
	buf := buffer.NewBufferSize(sk.BinarySize())
	_, err = sk.WriteTo(buf)
	return buf.Bytes(), err
}

// UnmarshalBinary decodes a slice of bytes generated by
// MarshalBinary or WriteTo on the object.
func (sk *SecretKey) UnmarshalBinary(p []byte) (err error) {
	_, err = sk.ReadFrom(buffer.NewBuffer(p))
	return
}

// PublicKey is a type for generic RLWE public keys.
// The Vector field stores the polynomials in NTT and Montgomery form.
type PublicKey struct {
	MetaData
	ring.Vector
}

// NewPublicKey returns a new PublicKey with zero values.
func NewPublicKey(params ParameterProvider) (pk *PublicKey) {
	pk = new(PublicKey)
	pk.FromBuffer(params, make([]uint64, pk.BufferSize(params)))
	pk.MetaData = MetaData{IsNTT: true, IsMontgomery: true}
	return
}

// FromBuffer assigns new backing array to the receiver.
// Method panics if len(buf) is too small.
// Minimum backing array size can be obtained with [BufferSize].
func (pk *PublicKey) FromBuffer(params ParameterProvider, buf []uint64) {
	if size := pk.BufferSize(params); len(buf) < size {
		panic(fmt.Errorf("invalid buffer size: len(buf)=%d < %d", len(buf), size))
	}
	p := params.GetRLWEParameters()
	pk.Vector.FromBuffer(p.N(), p.MaxLevelQ(), p.MaxLevelP(), 2, buf)
}

// BufferSize returns the minimum buffer size
// to instantiate the receiver through [FromBuffer].
func (pk *PublicKey) BufferSize(params ParameterProvider) int {
	p := params.GetRLWEParameters()
	return pk.Vector.BufferSize(p.N(), p.MaxLevelQ(), p.MaxLevelP(), 2)
}

// Clone creates a deep copy of the target PublicKey and returns it.
func (pk PublicKey) Clone() *PublicKey {
	return &PublicKey{Vector: *pk.Vector.Clone(), MetaData: *pk.MetaData.Clone()}
}

func (pk *PublicKey) isEncryptionKey() {}

// AsCiphertext wraps the receiver into an [rlwe.Ciphertext].
func (pk *PublicKey) AsCiphertext() *Ciphertext {
	return &Ciphertext{
		Vector:   &pk.Vector,
		MetaData: &pk.MetaData,
	}
}

// BinarySize returns the serialized size of the object in bytes.
func (pk PublicKey) BinarySize() (size int) {
	return pk.MetaData.BinarySize() + pk.Vector.BinarySize()
}

// WriteTo writes the object on an io.Writer. It implements the io.WriterTo
// interface, and will write exactly object.BinarySize() bytes on w.
//
// Unless w implements the buffer.Writer interface (see lattigo/utils/buffer/writer.go),
// it will be wrapped into a bufio.Writer. Since this requires allocations, it
// is preferable to pass a buffer.Writer directly:
//
//   - When writing multiple times to a io.Writer, it is preferable to first wrap the
//     io.Writer in a pre-allocated bufio.Writer.
//   - When writing to a pre-allocated var b []byte, it is preferable to pass
//     buffer.NewBuffer(b) as w (see lattigo/utils/buffer/buffer.go).
func (pk PublicKey) WriteTo(w io.Writer) (n int64, err error) {
	switch w := w.(type) {
	case buffer.Writer:

		var inc int64

		if inc, err = pk.MetaData.WriteTo(w); err != nil {
			return n + inc, err
		}

		n += inc

		if inc, err = pk.Vector.WriteTo(w); err != nil {
			return n + inc, err
		}

		return n + inc, err
	default:
		return pk.WriteTo(bufio.NewWriter(w))
	}
}

// ReadFrom reads on the object from an io.Writer. It implements the
// io.ReaderFrom interface.
//
// Unless r implements the buffer.Reader interface (see see lattigo/utils/buffer/reader.go),
// it will be wrapped into a bufio.Reader. Since this requires allocation, it
// is preferable to pass a buffer.Reader directly:
//
//   - When reading multiple values from a io.Reader, it is preferable to first
//     first wrap io.Reader in a pre-allocated bufio.Reader.
//   - When reading from a var b []byte, it is preferable to pass a buffer.NewBuffer(b)
//     as w (see lattigo/utils/buffer/buffer.go).
func (pk *PublicKey) ReadFrom(r io.Reader) (n int64, err error) {
	switch r := r.(type) {
	case buffer.Reader:

		var inc int64

		if inc, err = pk.MetaData.ReadFrom(r); err != nil {
			return n + inc, err
		}

		n += inc

		if inc, err = pk.Vector.ReadFrom(r); err != nil {
			return n + inc, err
		}

		return n + inc, err

	default:
		return pk.ReadFrom(bufio.NewReader(r))
	}
}

// MarshalBinary encodes the object into a binary form on a newly allocated slice of bytes.
func (pk PublicKey) MarshalBinary() (data []byte, err error) {
	buf := buffer.NewBufferSize(pk.BinarySize())
	_, err = pk.WriteTo(buf)
	return buf.Bytes(), err
}

// UnmarshalBinary decodes a slice of bytes generated by
// MarshalBinary or WriteTo on the object.
func (pk *PublicKey) UnmarshalBinary(p []byte) (err error) {
	_, err = pk.ReadFrom(buffer.NewBuffer(p))
	return
}

// EvaluationKey is a public key indented to be used during the evaluation phase of a homomorphic circuit.
// It provides a one way public and non-interactive re-encryption from a ciphertext encrypted under `skIn`
// to a ciphertext encrypted under `skOut`.
//
// Such re-encryption is for example used for:
//   - Homomorphic relinearization: re-encryption of a quadratic ciphertext (that requires (1, sk sk^2) to be decrypted)
//     to a linear ciphertext (that required (1, sk) to be decrypted). In this case skIn = sk^2 an skOut = sk.
//   - Homomorphic automorphisms: an automorphism in the ring Z[X]/(X^{N}+1) is defined as pi_k: X^{i} -> X^{i^k} with
//     k coprime to 2N. Pi_sk is for exampled used during homomorphic slot rotations. Applying pi_k to a ciphertext encrypted
//     under sk generates a new ciphertext encrypted under pi_k(sk), and an Evaluationkey skIn = pi_k(sk) to skOut = sk
//     is used to bring it back to its original key.
type EvaluationKey struct {
	GadgetCiphertext
}

type EvaluationKeyParameters struct {
	LevelQ *int
	LevelP *int
	DigitDecomposition
}

func ResolveEvaluationKeyParameters(params ParameterProvider, evkParams []EvaluationKeyParameters) (int, int, DigitDecomposition) {

	p := params.GetRLWEParameters()

	var LevelQ, LevelP int

	if len(evkParams) != 0 {
		if evkParams[0].LevelQ == nil {
			LevelQ = p.MaxLevelQ()
		} else {
			LevelQ = *evkParams[0].LevelQ
		}

		if evkParams[0].LevelP == nil {
			LevelP = p.MaxLevelP()
		} else {
			LevelP = *evkParams[0].LevelP
		}

		return LevelQ, LevelP, evkParams[0].DigitDecomposition
	}

	return p.MaxLevelQ(), p.MaxLevelP(), DigitDecomposition{}
}

// NewEvaluationKey returns a new EvaluationKey with pre-allocated zero-value.
func NewEvaluationKey(params ParameterProvider, evkParams ...EvaluationKeyParameters) (evk *EvaluationKey) {
	evk = new(EvaluationKey)
	evk.FromBuffer(params, make([]uint64, evk.BufferSize(params, evkParams...)), evkParams...)
	return
}

// FromBuffer assigns new backing array to the receiver.
// Method panics if len(buf) is too small.
// Minimum backing array size can be obtained with [BufferSize].
func (evk *EvaluationKey) FromBuffer(params ParameterProvider, buf []uint64, evkParams ...EvaluationKeyParameters) {
	if size := evk.BufferSize(params, evkParams...); len(buf) < size {
		panic(fmt.Errorf("invalid buffer size: len(buf)=%d < %d", len(buf), size))
	}
	LevelQ, LevelP, dd := ResolveEvaluationKeyParameters(params.GetRLWEParameters(), evkParams)
	evk.GadgetCiphertext.FromBuffer(params, 1, LevelQ, LevelP, dd, buf)
}

// BufferSize returns the minimum buffer size
// to instantiate the receiver through [FromBuffer].
func (evk *EvaluationKey) BufferSize(params ParameterProvider, evkParams ...EvaluationKeyParameters) int {
	p := *params.GetRLWEParameters()
	LevelQ, LevelP, dd := ResolveEvaluationKeyParameters(params, evkParams)
	return evk.GadgetCiphertext.BufferSize(p, 1, LevelQ, LevelP, dd)
}

// Clone creates a deep copy of the target EvaluationKey and returns it.
func (evk EvaluationKey) Clone() *EvaluationKey {
	return &EvaluationKey{GadgetCiphertext: *evk.GadgetCiphertext.Clone()}
}

// Equal performs a deep equal.
func (evk EvaluationKey) Equal(other *EvaluationKey) bool {
	return evk.GadgetCiphertext.Equal(&other.GadgetCiphertext)
}

// RelinearizationKey is type of evaluation key used for ciphertext multiplication compactness.
// The Relinearization key encrypts s^{2} under s and is used to homomorphically re-encrypt the
// degree 2 term of a ciphertext (the term that decrypt with s^{2}) into a degree 1 term
// (a term that decrypts with s).
type RelinearizationKey struct {
	EvaluationKey
}

// NewRelinearizationKey allocates a new RelinearizationKey with zero coefficients.
func NewRelinearizationKey(params ParameterProvider, evkParams ...EvaluationKeyParameters) (rlk *RelinearizationKey) {
	rlk = new(RelinearizationKey)
	rlk.FromBuffer(params, make([]uint64, rlk.BufferSize(params, evkParams...)), evkParams...)
	return
}

func (rlk *RelinearizationKey) FromBuffer(params ParameterProvider, buf []uint64, evkParams ...EvaluationKeyParameters) {
	if size := rlk.BufferSize(params, evkParams...); len(buf) < size {
		panic(fmt.Errorf("invalid buffer size: len(buf)=%d < %d", len(buf), size))
	}
	rlk.EvaluationKey.FromBuffer(params, buf, evkParams...)
}

// BufferSize returns the minimum buffer size
// to instantiate the receiver through [FromBuffer].
func (rlk *RelinearizationKey) BufferSize(params ParameterProvider, evkParams ...EvaluationKeyParameters) int {
	return rlk.EvaluationKey.BufferSize(params, evkParams...)
}

// Clone creates a deep copy of the object and returns it.
func (rlk RelinearizationKey) Clone() *RelinearizationKey {
	return &RelinearizationKey{EvaluationKey: *rlk.EvaluationKey.Clone()}
}

// Equal performs a deep equal.
func (rlk RelinearizationKey) Equal(other *RelinearizationKey) bool {
	return rlk.EvaluationKey.Equal(&other.EvaluationKey)
}

// GaloisKey is a type of evaluation key used to evaluate automorphisms on ciphertext.
// An automorphism pi: X^{i} -> X^{i*GaloisElement} changes the key under which the
// ciphertext is encrypted from s to pi(s). Thus, the ciphertext must be re-encrypted
// from pi(s) to s to ensure correctness, which is done with the corresponding GaloisKey.
//
// Lattigo implements automorphisms differently than the usual way (which is to first
// apply the automorphism and then the evaluation key). Instead the order of operations
// is reversed, the GaloisKey for pi^{-1} is evaluated on the ciphertext, outputting a
// ciphertext encrypted under pi^{-1}(s), and then the automorphism pi is applied. This
// enables a more efficient evaluation, by only having to apply the automorphism on the
// final result (instead of having to apply it on the decomposed ciphertext).
type GaloisKey struct {
	GaloisElement uint64
	NthRoot       uint64
	EvaluationKey
}

// NewGaloisKey allocates a new GaloisKey with zero coefficients and GaloisElement set to zero.
func NewGaloisKey(params ParameterProvider, evkParams ...EvaluationKeyParameters) (gk *GaloisKey) {
	gk = new(GaloisKey)
	gk.EvaluationKey.FromBuffer(params, make([]uint64, gk.BufferSize(params, evkParams...)), evkParams...)
	return
}

// FromBuffer assigns new backing array to the receiver.
// Method panics if len(buf) is too small.
// Minimum backing array size can be obtained with [BufferSize].
func (gk *GaloisKey) FromBuffer(params ParameterProvider, buf []uint64, evkParams ...EvaluationKeyParameters) {

	if size := gk.BufferSize(params, evkParams...); len(buf) < size {
		panic(fmt.Errorf("invalid buffer size: len(buf)=%d < %d", len(buf), size))
	}

	gk.EvaluationKey.FromBuffer(params, buf, evkParams...)
}

// BufferSize returns the minimum buffer size
// to instantiate the receiver through [FromBuffer].
func (gk *GaloisKey) BufferSize(params ParameterProvider, evkParams ...EvaluationKeyParameters) int {
	return gk.EvaluationKey.BufferSize(params, evkParams...)
}

// Equal returns true if the two objects are equal.
func (gk GaloisKey) Equal(other *GaloisKey) bool {
	return gk.GaloisElement == other.GaloisElement && gk.NthRoot == other.NthRoot && cmp.Equal(gk.EvaluationKey, other.EvaluationKey)
}

// Clone creates a deep copy of the object and returns it
func (gk GaloisKey) Clone() *GaloisKey {
	return &GaloisKey{
		GaloisElement: gk.GaloisElement,
		NthRoot:       gk.NthRoot,
		EvaluationKey: *gk.EvaluationKey.Clone(),
	}
}

// BinarySize returns the serialized size of the object in bytes.
func (gk GaloisKey) BinarySize() (size int) {
	return gk.EvaluationKey.BinarySize() + 16
}

// WriteTo writes the object on an io.Writer. It implements the io.WriterTo
// interface, and will write exactly object.BinarySize() bytes on w.
//
// Unless w implements the buffer.Writer interface (see lattigo/utils/buffer/writer.go),
// it will be wrapped into a bufio.Writer. Since this requires allocations, it
// is preferable to pass a buffer.Writer directly:
//
//   - When writing multiple times to a io.Writer, it is preferable to first wrap the
//     io.Writer in a pre-allocated bufio.Writer.
//   - When writing to a pre-allocated var b []byte, it is preferable to pass
//     buffer.NewBuffer(b) as w (see lattigo/utils/buffer/buffer.go).
func (gk GaloisKey) WriteTo(w io.Writer) (n int64, err error) {
	switch w := w.(type) {
	case buffer.Writer:

		var inc int64

		if inc, err = buffer.WriteUint64(w, gk.GaloisElement); err != nil {
			return n + inc, err
		}

		n += inc

		if inc, err = buffer.WriteUint64(w, gk.NthRoot); err != nil {
			return n + inc, err
		}

		n += inc

		if inc, err = gk.EvaluationKey.WriteTo(w); err != nil {
			return n + inc, err
		}

		n += inc

		return

	default:
		return gk.WriteTo(bufio.NewWriter(w))
	}
}

// ReadFrom reads on the object from an io.Writer. It implements the
// io.ReaderFrom interface.
//
// Unless r implements the buffer.Reader interface (see see lattigo/utils/buffer/reader.go),
// it will be wrapped into a bufio.Reader. Since this requires allocation, it
// is preferable to pass a buffer.Reader directly:
//
//   - When reading multiple values from a io.Reader, it is preferable to first
//     first wrap io.Reader in a pre-allocated bufio.Reader.
//   - When reading from a var b []byte, it is preferable to pass a buffer.NewBuffer(b)
//     as w (see lattigo/utils/buffer/buffer.go).
func (gk *GaloisKey) ReadFrom(r io.Reader) (n int64, err error) {
	switch r := r.(type) {
	case buffer.Reader:

		var inc int64

		if inc, err = buffer.ReadUint64(r, &gk.GaloisElement); err != nil {
			return n + inc, err
		}

		n += inc

		if inc, err = buffer.ReadUint64(r, &gk.NthRoot); err != nil {
			return n + inc, err
		}

		n += inc

		if inc, err = gk.EvaluationKey.ReadFrom(r); err != nil {
			return n + inc, err
		}

		n += inc

		return
	default:
		return gk.ReadFrom(bufio.NewReader(r))
	}
}

// MarshalBinary encodes the object into a binary form on a newly allocated slice of bytes.
func (gk GaloisKey) MarshalBinary() (p []byte, err error) {
	buf := buffer.NewBufferSize(gk.BinarySize())
	_, err = gk.WriteTo(buf)
	return buf.Bytes(), err
}

// UnmarshalBinary decodes a slice of bytes generated by
// MarshalBinary or WriteTo on the object.
func (gk *GaloisKey) UnmarshalBinary(p []byte) (err error) {
	_, err = gk.ReadFrom(buffer.NewBuffer(p))
	return
}

// EvaluationKeySet is an interface implementing methods
// to load the RelinearizationKey and GaloisKeys in the Evaluator.
// Implementations of this interface must be safe for concurrent use.
type EvaluationKeySet interface {

	// GetGaloisKey retrieves the Galois key for the automorphism X^{i} -> X^{i*galEl}.
	GetGaloisKey(galEl uint64) (evk *GaloisKey, err error)

	// GetGaloisKeysList returns the list of all the Galois elements
	// for which a Galois key exists in the object.
	GetGaloisKeysList() (galEls []uint64)

	// GetRelinearizationKey retrieves the RelinearizationKey.
	GetRelinearizationKey() (evk *RelinearizationKey, err error)
}

// MemEvaluationKeySet is a basic in-memory implementation of the EvaluationKeySet interface.
type MemEvaluationKeySet struct {
	RelinearizationKey *RelinearizationKey
	GaloisKeys         structs.Map[uint64, GaloisKey]
}

// NewMemEvaluationKeySet returns a new EvaluationKeySet with the provided RelinearizationKey and GaloisKeys.
func NewMemEvaluationKeySet(relinKey *RelinearizationKey, galoisKeys ...*GaloisKey) (eks *MemEvaluationKeySet) {
	eks = &MemEvaluationKeySet{GaloisKeys: map[uint64]*GaloisKey{}}
	eks.RelinearizationKey = relinKey
	for _, k := range galoisKeys {
		eks.GaloisKeys[k.GaloisElement] = k
	}
	return eks
}

// GetGaloisKey retrieves the Galois key for the automorphism X^{i} -> X^{i*galEl}.
func (evk MemEvaluationKeySet) GetGaloisKey(galEl uint64) (gk *GaloisKey, err error) {
	var ok bool
	if gk, ok = evk.GaloisKeys[galEl]; !ok {
		return nil, fmt.Errorf("GaloisKey[%d] is nil", galEl)
	}

	return
}

// GetGaloisKeysList returns the list of all the Galois elements
// for which a Galois key exists in the object.
func (evk MemEvaluationKeySet) GetGaloisKeysList() (galEls []uint64) {

	if evk.GaloisKeys == nil {
		return []uint64{}
	}

	galEls = make([]uint64, len(evk.GaloisKeys))

	var i int
	for galEl := range evk.GaloisKeys {
		galEls[i] = galEl
		i++
	}

	return
}

// GetRelinearizationKey retrieves the RelinearizationKey.
func (evk MemEvaluationKeySet) GetRelinearizationKey() (rk *RelinearizationKey, err error) {
	if evk.RelinearizationKey != nil {
		return evk.RelinearizationKey, nil
	}

	return nil, fmt.Errorf("RelinearizationKey is nil")
}

func (evk MemEvaluationKeySet) BinarySize() (size int) {

	size++
	if evk.RelinearizationKey != nil {
		size += evk.RelinearizationKey.BinarySize()
	}

	size++
	if evk.GaloisKeys != nil {
		size += evk.GaloisKeys.BinarySize()
	}

	return
}

// WriteTo writes the object on an io.Writer. It implements the io.WriterTo
// interface, and will write exactly object.BinarySize() bytes on w.
//
// Unless w implements the buffer.Writer interface (see lattigo/utils/buffer/writer.go),
// it will be wrapped into a bufio.Writer. Since this requires allocations, it
// is preferable to pass a buffer.Writer directly:
//
//   - When writing multiple times to a io.Writer, it is preferable to first wrap the
//     io.Writer in a pre-allocated bufio.Writer.
//   - When writing to a pre-allocated var b []byte, it is preferable to pass
//     buffer.NewBuffer(b) as w (see lattigo/utils/buffer/buffer.go).
func (evk MemEvaluationKeySet) WriteTo(w io.Writer) (n int64, err error) {
	switch w := w.(type) {
	case buffer.Writer:

		var inc int64

		if evk.RelinearizationKey != nil {
			if inc, err = buffer.WriteUint8(w, 1); err != nil {
				return inc, err
			}

			n += inc

			if inc, err = evk.RelinearizationKey.WriteTo(w); err != nil {
				return n + inc, err
			}

			n += inc

		} else {
			if inc, err = buffer.WriteUint8(w, 0); err != nil {
				return inc, err
			}
			n += inc
		}

		if evk.GaloisKeys != nil {
			if inc, err = buffer.WriteUint8(w, 1); err != nil {
				return inc, err
			}

			n += inc

			if inc, err = evk.GaloisKeys.WriteTo(w); err != nil {
				return n + inc, err
			}

			n += inc

		} else {
			if inc, err = buffer.WriteUint8(w, 0); err != nil {
				return inc, err
			}
			n += inc
		}

		return n, w.Flush()

	default:
		return evk.WriteTo(bufio.NewWriter(w))
	}
}

// ReadFrom reads on the object from an io.Writer. It implements the
// io.ReaderFrom interface.
//
// Unless r implements the buffer.Reader interface (see see lattigo/utils/buffer/reader.go),
// it will be wrapped into a bufio.Reader. Since this requires allocation, it
// is preferable to pass a buffer.Reader directly:
//
//   - When reading multiple values from a io.Reader, it is preferable to first
//     first wrap io.Reader in a pre-allocated bufio.Reader.
//   - When reading from a var b []byte, it is preferable to pass a buffer.NewBuffer(b)
//     as w (see lattigo/utils/buffer/buffer.go).
func (evk *MemEvaluationKeySet) ReadFrom(r io.Reader) (n int64, err error) {
	switch r := r.(type) {
	case buffer.Reader:

		var inc int64

		var hasKey uint8

		if inc, err = buffer.ReadUint8(r, &hasKey); err != nil {
			return inc, err
		}

		n += inc

		if hasKey == 1 {

			if evk.RelinearizationKey == nil {
				evk.RelinearizationKey = new(RelinearizationKey)
			}

			if inc, err = evk.RelinearizationKey.ReadFrom(r); err != nil {
				return n + inc, err
			}

			n += inc
		}

		if inc, err = buffer.ReadUint8(r, &hasKey); err != nil {
			return inc, err
		}

		n += inc

		if hasKey == 1 {

			if evk.GaloisKeys == nil {
				evk.GaloisKeys = structs.Map[uint64, GaloisKey]{}
			}

			if inc, err = evk.GaloisKeys.ReadFrom(r); err != nil {
				return n + inc, err
			}

			n += inc
		}

		return n, nil

	default:
		return evk.ReadFrom(bufio.NewReader(r))
	}
}

// MarshalBinary encodes the object into a binary form on a newly allocated slice of bytes.
func (evk MemEvaluationKeySet) MarshalBinary() (p []byte, err error) {
	buf := buffer.NewBufferSize(evk.BinarySize())
	_, err = evk.WriteTo(buf)
	return buf.Bytes(), err
}

// UnmarshalBinary decodes a slice of bytes generated by
// MarshalBinary or WriteTo on the object.
func (evk *MemEvaluationKeySet) UnmarshalBinary(p []byte) (err error) {
	_, err = evk.ReadFrom(buffer.NewBuffer(p))
	return
}
