package ring

import (
	"fmt"
	"io"

	"github.com/Pro7ech/lattigo/utils/structs"
)

// Poly is a structure storing the coefficients of a polynomial.
type Poly []uint64

// BufferSize returns the minimum buffer size
// to instantiate the receiver through [FromBuffer].
func (p Poly) BufferSize(N int) int {
	return N
}

// FromBuffer assigns new backing array to the receiver.
func (p *Poly) FromBuffer(N int, buf []uint64) {

	if len(buf) < p.BufferSize(N) {
		panic(fmt.Errorf("invalid buffer size: N=%d < len(p)=%d", N, len(buf)))
	}

	*p = make([]uint64, N)
}

// NewPoly allocates a new [Poly] of N coefficients.
func NewPoly(N int) (p Poly) {
	p.FromBuffer(N, make([]uint64, p.BufferSize(N)))
	return
}

// N returns the number of coefficients of the [Poly].
func (p Poly) N() int {
	return len(p)
}

// Clone returns a deep copy of the receiver.
func (p Poly) Clone() *Poly {
	pCpy := Poly(structs.Vector[uint64](p).Clone())
	return &pCpy
}

// Copy copies the coefficients of on the receiver.
func (p *Poly) Copy(other *Poly) {
	copy(*p, *other)
}

// Equal performs a deep equal.
func (p Poly) Equal(other *Poly) bool {
	return structs.Vector[uint64](p).Equal(structs.Vector[uint64](*other))
}

// BinarySize returns the serialized size of the object in bytes.
func (p Poly) BinarySize() (size int) {
	return structs.Vector[uint64](p).BinarySize()
}

// WriteTo writes the object on an io.Writer. It implements the io.WriterTo
// interface, and will write exactly object.BinarySize() bytes on w.
//
// Unless w implements the buffer.Writer interface (see lattigo/utils/buffer/writer.go),
// it will be wrapped into a bufio.Writer. Since this requires allocations, it
// is preferable to pass a buffer.Writer directly:
//
//   - When writing multiple times to a io.Writer, it is preferable to first wrap the
//     io.Writer in a pre-allocated bufio.Writer.
//   - When writing to a pre-allocated var b []byte, it is preferable to pass
//     buffer.NewBuffer(b) as w (see lattigo/utils/buffer/buffer.go).
func (p Poly) WriteTo(w io.Writer) (n int64, err error) {
	return structs.Vector[uint64](p).WriteTo(w)
}

// ReadFrom reads on the object from an io.Writer. It implements the
// io.ReaderFrom interface.
//
// Unless r implements the buffer.Reader interface (see see lattigo/utils/buffer/reader.go),
// it will be wrapped into a bufio.Reader. Since this requires allocation, it
// is preferable to pass a buffer.Reader directly:
//
//   - When reading multiple values from a io.Reader, it is preferable to first
//     first wrap io.Reader in a pre-allocated bufio.Reader.
//   - When reading from a var b []byte, it is preferable to pass a buffer.NewBuffer(b)
//     as w (see lattigo/utils/buffer/buffer.go).
func (p *Poly) ReadFrom(r io.Reader) (n int64, err error) {
	v := structs.Vector[uint64](*p)
	if n, err = v.ReadFrom(r); err != nil {
		return
	}
	*p = []uint64(v)
	return
}

// MarshalBinary encodes the object into a binary form on a newly allocated slice of bytes.
func (p Poly) MarshalBinary() (data []byte, err error) {
	return structs.Vector[uint64](p).MarshalBinary()
}

// UnmarshalBinary decodes a slice of bytes generated by
// MarshalBinary or WriteTo on the object.
func (p *Poly) UnmarshalBinary(data []byte) (err error) {
	v := structs.Vector[uint64](*p)
	if err = v.UnmarshalBinary(data); err != nil {
		return
	}
	*p = []uint64(v)
	return
}
