// Package sampling implements secure sampling.
package sampling

import (
	crypto "crypto/rand"
	"encoding/binary"
	"math/rand/v2"
)

// NewSeed returns a 32 byte seed populated with
// cryptographically secure random bytes.
func NewSeed() (seed [32]byte) {
	if _, err := crypto.Read(seed[:]); err != nil {
		panic(err)
	}
	return
}

type Source struct {
	buff [8]byte
	rand.ChaCha8
}

func NewSource(seed [32]byte) *Source {
	return &Source{ChaCha8: *rand.NewChaCha8(seed)}
}

// NewSeed returns a new seed populated with bytes
// generated by the receiver.
func (s *Source) NewSeed() (seed [32]byte) {
	if _, err := s.Read(seed[:]); err != nil {
		panic(err)
	}
	return
}

// NewSource returns a new [sampling.Source] seeded
// with bytes generated by the receiver.
func (s *Source) NewSource() *Source {
	return NewSource(s.NewSeed())
}

// Float64 returns a pseudo random float64 in the interval [min, max).
func (s *Source) Float64(min, max float64) float64 {
	return min + float64(s.Uint64()<<11>>11)/(1<<53)*(max-min)
}

// Complex128 returns a pseudo random complex128 in with
// the real part in the interval [real(min), real(max)),
// the imag part in the interval [imag(min), imag(max)).
func (s *Source) Complex128(min, max complex128) complex128 {
	return complex(s.Float64(real(min), real(max)), s.Float64(imag(min), imag(max)))
}

// Read complies to the io.Reader interface.
func (s *Source) Read(b []byte) (n int, err error) {

	size := len(b)

	if size < 8 {
		binary.LittleEndian.PutUint64(s.buff[:], s.Uint64())
		copy(b, s.buff[:])
		return len(b), nil
	}

	for i := 0; i < (size>>3)<<3; i += 8 {
		binary.LittleEndian.PutUint64(b[i:], s.Uint64())
	}

	// If len(b) is not a multiple of 8, we fill the last 8 bytes
	// of b, possibly overwriting previously filled bytes.
	if size&7 != 0 {
		binary.LittleEndian.PutUint64(b[size-8:], s.Uint64())
	}

	return len(b), nil
}
